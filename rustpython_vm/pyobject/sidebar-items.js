initSidebarItems({"enum":[["Either",""],["PyArithmaticValue",""]],"struct":[["PyCallable",""],["PyContext",""],["PyEllipsis",""],["PyIterable","An iterable Python object."],["PyIterator",""],["PyNotImplemented",""],["PyObject","This is an actual python object. It consists of a `typ` which is the python class, and carries some rust payload optionally. This rust payload can be a rust float or rust int in case of float and int objects."],["PyRef","A reference to a Python object."]],"trait":[["BufferProtocol",""],["IdProtocol",""],["IntoPyObject","Implemented by any type that can be returned from a built-in Python function."],["ItemProtocol","The python item protocol. Mostly applies to dictionaries. Allows getting, setting and deletion of keys-value pairs."],["PyClassDef",""],["PyClassImpl",""],["PyObjectPayload",""],["PyValue",""],["TryFromObject","Implemented by any type that can be created from a Python object."],["TryIntoRef","Allows coercion of a types into PyRefs, so that we can write functions that can take refs, pyobject refs or basic types."],["TypeProtocol",""]],"type":[["PyAttributes","For attributes we do not use a dict, but a hashmap. This is probably faster, unordered, and only supports strings as keys. TODO: class attributes should maintain insertion order (use IndexMap here)"],["PyComparisonValue",""],["PyEllipsisRef",""],["PyNotImplementedRef",""],["PyObjectRef","The `PyObjectRef` is one of the most used types. It is a reference to a python object. A single python object can have multiple references, and this reference counting is accounted for by this type. Use the `.clone()` method to create a new reference and increment the amount of references to the python object by 1."],["PyResult","Use this type for functions which return a python object or an exception. Both the python object and the python exception are `PyObjectRef` types since exceptions are also python objects."]]});